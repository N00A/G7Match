1 - los casos de uso apuntan a una sola funcionalidad, debe de ser descrita extensamente, no usar el verbo gestionar

2 - entre mayor detalle, mejor

3 - Atributos de calidad (requerimientos no funcionales):

* observables: si las veo en el codigo
* no observables: si no las veo en el codigo pero si en un comportamiento

4 - para la utilizacion de recursos que quede de manera optima se debe usar la inyeccion de dependencias

5 - Swagger sirve para documentar la API expuesta, de manera que se puede ver que metodos existen, que debo enviar y que me van a devolver

6 - JPA es un API generico que permite heredar lo que hay en la interfaz IRespository utilizando lo que hay en Service, de modo de que asi no necesito crear los CRUD manualmente por cada uno de los modelos que tengo

7 - Lombok es para generar automaticamente en tiempo de ejecucion los metodos set y get de cada uno de los modelos del sistema, Lombok tambien permite hacer constructores e instancias de clases

8 - Flyway Migration es para gestionar todos los scripts que van evolucionando de la base de datos dentro del proyecto a travez de un versionador de scripts dentro del proyecto

9 - No usar puertos por defecto

10 - todas las aplicaciones llevan login

11 - Las pruebas unitarias se hacen desde el service para que compruebe el service y el repository

12 - Las pruebas de integracion se le hacen al RestController y se hacen desde herramientas externas, por ejemplo: Postman

13 - El openapi es el Swagger:

implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.3.0'

14 - Las pruebas que se le hacen al controller son pruebas de integracion

15 - server.servlet.context-path=/api/demo en application.properties sirve para darle mas control al API si tengo varias que coexisten

16 - jacocoTestReport permite medir que tanta cobertura tienen las pruebas unitarias, los reportes son utiles para saber que tanto me falta cubrir en las pruebas unitarias y garantizar mejor calidad

17 - sonarcloud es el analizador estatico de codigo, para que funcione bien el repositorio de codigo debe de ser publico

18 - JUnit es el framework de pruebas (anotaciones, ciclo de vida, asserts), mientras que Mockito sirve para aislar dependiencias (simular una clase, como el repository)

19 - Las pruebas unitarias comprueban dos cosas: la primera es comprobar que funciona (correctitud, que haga lo que debe hacer) y la otra prueba es que se debe de validar que el manejo de errores este dado

20 - Para la contraseña del login del usuario se debe usar SHA-256 en un solo sentido, el profesor sugiere explorar spring security

21 - Todos los componentes necesitan el JWT Token (Bearer token) menos el login y la creacion de usuario

22 - Lo ideal es que el codigo en Java debe de estar en Ingles y con anotacion CamelCase, por lo general no se usan numeros en el nombrado de paquetes

23 - No usar cedulas o numeros para nombrar las ramas de git

24 - Ejemplo de rama: Mpastrana, Csanchez

25 - De la rama de Main se desprende la rama de integracion (Develop), la rama de integracion esta bloqueada para subir cambios directamente, la rama main tambien esta bloqueada para subir cambios directamente, solo se puede subir cambios por medio de pull request, de la rama Develop se desprende una rama para cada uno de los miembros del equipo, cada miembro del equipo trabaja sobre su propia rama, cada desarrollador en su rama si puede hacer push y pull sin restriccion

26 - El desarrollador al terminar su desarrollo debe de hacer tambien sus pruebas unitarias y probar tambien con postman

27 - Al hacer pull request otro miembro del equipo debe de revisar y aprobar la solicitud o rechazarla si tiene errores

28 - La rama de integracion (Develop) es la que va a tener la integracion continua con git actions, el git actions tiene un conjunto de instrucciones que son: hacer el build, ejecutar el test, ejecutar sonar, esto es el script de integracion continua, el script lo que hace es que cuando ya aprobaron el pull request a Develop intenta hacer el build, para poder hacer el build tiene que ejecutar las pruebas unitarias, si pasaron entonces se crea la unidad desplegable, si se pudo crear la unidad desplegable entonces se ejecuta el sonar tomando el codigo que esta en Develop y revisa estaticamente el codigo y genera el reporte en la nube

29 - El git actions no funciona con una base de datos local

30 - Lo recomendable es crear la base de datos online en AWS con estancia Ec2 con una maquina t3 amilinux que es capa gratuita y adentro instalar docker, hacer docker pull de la base de datos que se necesita, se conecta a la base de datos, le crean la base de datos y cambiar la cadena de conexion en el proyecto, no utilizar dynamo db ni rds porque esas cobran despues de un periodo de tiempo

31 - http://localhost:9090/api/rdg7/swagger-ui/index.html = Web Swagger

32 - overall code = código general